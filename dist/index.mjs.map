{"version":3,"sources":["../src/libraries/ApiClient.js","../src/services/ApiManager.js","../src/hooks/useApiBase.js","../src/hooks/useScreenFocus.js","../src/hooks/useParallelApi.js","../src/hooks/useApiNavigation.js"],"sourcesContent":["/**\n * Custom error class for API-related errors with structured information.\n * \n * @class ApiError\n * @extends {Error}\n */\nexport class ApiError extends Error {\n  /**\n   * Creates an instance of ApiError.\n   * \n   * @param {string} message - The error message\n   * @param {number} status - The HTTP status code\n   * @param {any} data - The parsed JSON error response from the server\n   */\n  constructor(message, status, data) {\n    super(message);\n    this.name = 'ApiError';\n    this.status = status;\n    this.data = data;\n  }\n}\n\n/**\n * Safely parses JSON response with fallback extraction for malformed JSON.\n * First attempts normal parsing, then tries to extract JSON from mixed content.\n * \n * @param {string} responseBody - The raw text from the response\n * @returns {any} The parsed JSON data or null if empty\n * @throws {Error} Original parse error if all attempts fail\n */\nconst parseJsonSafely = (responseBody) => {\n  if (!responseBody) return null;\n  \n  try {\n    return JSON.parse(responseBody);\n  } catch (parseError) {\n    // Attempt to extract JSON from mixed content\n    try {\n      const openBraceIndex = responseBody.indexOf('{');\n      const openBracketIndex = responseBody.indexOf('[');\n      \n      // Find the first occurrence of JSON start\n      let startIndex = -1;\n      if (openBraceIndex === -1) {\n        startIndex = openBracketIndex;\n      } else if (openBracketIndex === -1) {\n        startIndex = openBraceIndex;\n      } else {\n        startIndex = Math.min(openBraceIndex, openBracketIndex);\n      }\n      \n      if (startIndex === -1) throw parseError;\n      \n      // Find the last occurrence of JSON end\n      const closeBraceIndex = responseBody.lastIndexOf('}');\n      const closeBracketIndex = responseBody.lastIndexOf(']');\n      const endIndex = Math.max(closeBraceIndex, closeBracketIndex);\n      \n      if (endIndex === -1) throw parseError;\n      \n      const extractedJson = responseBody.substring(startIndex, endIndex + 1);\n      return JSON.parse(extractedJson);\n    } catch {\n      throw parseError;\n    }\n  }\n};\n\n/**\n * Parses a URI string that may contain a method prefix (e.g., 'post:users').\n * Supports standard HTTP methods and handles edge cases like URLs with colons.\n * \n * @param {string} uri - The URI string, optionally prefixed with method\n * @param {string} [defaultMethod='GET'] - The default HTTP method to use\n * @returns {{method: string, endpoint: string}} Parsed method and endpoint\n */\nconst parseUriAndMethod = (uri, defaultMethod = 'GET') => {\n  const VALID_HTTP_METHODS = ['GET', 'POST', 'PUT', 'DELETE', 'PATCH', 'HEAD', 'OPTIONS'];\n  \n  if (!uri.includes(':')) {\n    return { method: defaultMethod.toUpperCase(), endpoint: uri };\n  }\n  \n  const [methodCandidate, ...endpointParts] = uri.split(':');\n  const upperCaseMethod = methodCandidate.toUpperCase();\n  \n  if (VALID_HTTP_METHODS.includes(upperCaseMethod)) {\n    return {\n      method: upperCaseMethod,\n      endpoint: endpointParts.join(':')\n    };\n  }\n  \n  return { method: defaultMethod.toUpperCase(), endpoint: uri };\n};\n\n/**\n * Creates a configured instance of the API Client with fetch-based HTTP functionality.\n * \n * @param {Object} config - Configuration object for the API client\n * @param {string} config.baseUrl - Base URL for all requests\n * @param {Object} [config.headers] - Default headers to include with requests\n * @param {Function} [config.getDynamicHeaders] - Async function to get dynamic headers\n * @param {Object} [config.interceptors] - Request/response interceptors\n * @param {Function} [config.interceptors.onRequest] - Request interceptor\n * @param {Function} [config.interceptors.onResponse] - Response interceptor\n * @param {Function} [config.interceptors.onError] - Error interceptor\n * @param {Function} [config.interceptors.onFinally] - Finally interceptor\n * @param {boolean} [config.returnNullOnAbort=true] - Return null when request is aborted\n * @returns {Object} Configured API client instance\n */\nexport const createApiClient = (config = {}) => {\n  let abortController = new AbortController();\n  const dynamicHeaders = new Map();\n\n  /**\n   * Builds the full URL by combining base URL and endpoint.\n   * \n   * @param {string} baseUrl - The base URL\n   * @param {string} endpoint - The endpoint path\n   * @returns {string} The full URL with normalized slashes\n   */\n  const buildFullUrl = (baseUrl, endpoint) => {\n    return `${baseUrl}/${endpoint}`.replace(/([^:]\\/)\\/+/g, '$1');\n  };\n\n  /**\n   * Builds request headers from various sources.\n   * \n   * @param {Object} config - API client configuration\n   * @param {Object} requestOptions - Request-specific options\n   * @param {Map} dynamicHeadersMap - Dynamic headers map\n   * @returns {Promise<Headers>} The constructed Headers object\n   */\n  const buildRequestHeaders = async (config, requestOptions, dynamicHeadersMap) => {\n    const headers = new Headers(config.headers || {});\n    \n    // Set default content type for non-FormData requests\n    if (!(requestOptions.body instanceof FormData)) {\n      headers.set('Content-Type', 'application/json');\n    }\n    \n    // Add dynamic headers from configuration\n    if (config.getDynamicHeaders) {\n      const configDynamicHeaders = await config.getDynamicHeaders();\n      Object.entries(configDynamicHeaders).forEach(([key, value]) => {\n        headers.set(key, value);\n      });\n    }\n    \n    // Add runtime dynamic headers\n    dynamicHeadersMap.forEach((value, key) => {\n      headers.set(key, value);\n    });\n    \n    // Add request-specific headers\n    if (requestOptions.headers) {\n      Object.entries(requestOptions.headers).forEach(([key, value]) => {\n        headers.set(key, value);\n      });\n    }\n    \n    // Remove content-type for FormData to let browser set it with boundary\n    if (requestOptions.body instanceof FormData) {\n      headers.delete('Content-Type');\n    }\n    \n    return headers;\n  };\n\n  /**\n   * Internal function to send HTTP requests with full interceptor support.\n   * \n   * @param {string} uri - The URI to send the request to\n   * @param {Object} requestOptions - Options for the request\n   * @returns {Promise<any>} The response data\n   */\n  const sendRequest = async (uri, requestOptions = {}) => {\n    const requestContext = { uri, options: requestOptions };\n\n    try {\n      const { method, endpoint } = parseUriAndMethod(uri, requestOptions.method);\n      const fullUrl = buildFullUrl(config.baseUrl, endpoint);\n      const requestHeaders = await buildRequestHeaders(config, requestOptions, dynamicHeaders);\n      \n      let fetchOptions = {\n        ...requestOptions,\n        method,\n        headers: requestHeaders,\n        signal: abortController.signal\n      };\n\n      // Run request interceptors\n      if (config.interceptors?.onRequest) {\n        const result = await config.interceptors.onRequest(fetchOptions, requestContext);\n        if (result !== undefined) return result;\n      }\n      if (requestOptions.onRequest) {\n        const result = await requestOptions.onRequest(fetchOptions, requestContext);\n        if (result !== undefined) return result;\n      }\n\n      // Make the HTTP request\n      const response = await fetch(fullUrl, fetchOptions);\n      const responseBodyText = await response.text();\n      \n      // Parse response body\n      let responseData;\n      try {\n        responseData = parseJsonSafely(responseBodyText);\n      } catch (parseError) {\n        throw new ApiError(\n          'Invalid JSON response from server', \n          response.status, \n          responseBodyText\n        );\n      }\n\n      // Check for HTTP errors\n      if (!response.ok) {\n        throw new ApiError(\n          responseData?.message || `Request failed with status ${response.status}`, \n          response.status, \n          responseData\n        );\n      }\n\n      // Run response interceptors\n      let finalData = responseData;\n      if (config.interceptors?.onResponse) {\n        finalData = await config.interceptors.onResponse(finalData, response);\n      }\n      if (requestOptions.onResponse) {\n        finalData = await requestOptions.onResponse(finalData, response);\n      }\n\n      return finalData;\n      \n    } catch (error) {\n      // Handle abort errors\n      if (error.name === 'AbortError') {\n        if (config.returnNullOnAbort !== false) return null;\n      }\n\n      // Run error interceptors\n      if (config.interceptors?.onError) {\n        return config.interceptors.onError(error);\n      }\n      \n      throw error;\n    } finally {\n      // Run finally interceptors\n      if (config.interceptors?.onFinally) {\n        await config.interceptors.onFinally();\n      }\n    }\n  };\n\n  // Public API client interface\n  const apiClient = {\n    /**\n     * Aborts the current request and creates a new AbortController.\n     */\n    abort: () => {\n      abortController.abort();\n      abortController = new AbortController();\n    },\n\n    /**\n     * Sets a dynamic header that will be included in all subsequent requests.\n     * \n     * @param {string} key - Header name\n     * @param {string} value - Header value\n     */\n    setHeader: (key, value) => dynamicHeaders.set(key, value),\n\n    /**\n     * Removes a dynamic header.\n     * \n     * @param {string} key - Header name to remove\n     */\n    unsetHeader: (key) => dynamicHeaders.delete(key),\n\n    /**\n     * Clears all dynamic headers.\n     */\n    clearHeaders: () => dynamicHeaders.clear(),\n\n    /**\n     * Makes a generic HTTP request with the specified URI and options.\n     * \n     * @param {string} uri - The URI to request, optionally prefixed with method\n     * @param {Object} [options={}] - Request options\n     * @param {Object} [options.params] - Query parameters to append to URL\n     * @param {any} [options.body] - Request body data\n     * @param {Object} [options.headers] - Request-specific headers\n     * @returns {Promise<any>} The response data\n     */\n    request: (uri, options = {}) => {\n      const { body, params, ...restOptions } = options;\n\n      let requestUri = uri;\n      \n      // Add query parameters if provided\n      if (params) {\n        const queryString = new URLSearchParams(params).toString();\n        const { endpoint } = parseUriAndMethod(uri, options.method);\n        const uriParts = uri.split(':');\n        const methodPrefix = uriParts.length > 1 ? `${uriParts[0]}:` : '';\n        requestUri = `${methodPrefix}${endpoint}?${queryString}`;\n      }\n\n      // Prepare request body\n      let requestBody;\n      if (body) {\n        requestBody = body instanceof FormData ? body : JSON.stringify(body);\n      }\n\n      return sendRequest(requestUri, {\n        ...restOptions,\n        body: requestBody,\n      });\n    },\n\n    /**\n     * Makes a GET request.\n     * \n     * @param {string} uri - The URI to request\n     * @param {Object} [params] - Query parameters\n     * @param {Object} [options] - Additional request options\n     * @returns {Promise<any>} The response data\n     */\n    get: (uri, params, options) => \n      apiClient.request(uri, { params, ...options, method: 'GET' }),\n\n    /**\n     * Makes a POST request.\n     * \n     * @param {string} uri - The URI to request\n     * @param {any} [body] - Request body data\n     * @param {Object} [options] - Additional request options\n     * @returns {Promise<any>} The response data\n     */\n    post: (uri, body, options) => \n      apiClient.request(uri, { body, ...options, method: 'POST' }),\n\n    /**\n     * Makes a PUT request.\n     * \n     * @param {string} uri - The URI to request\n     * @param {any} [body] - Request body data\n     * @param {Object} [options] - Additional request options\n     * @returns {Promise<any>} The response data\n     */\n    put: (uri, body, options) => \n      apiClient.request(uri, { body, ...options, method: 'PUT' }),\n\n    /**\n     * Makes a DELETE request.\n     * \n     * @param {string} uri - The URI to request\n     * @param {Object} [options] - Additional request options\n     * @returns {Promise<any>} The response data\n     */\n    del: (uri, options) => \n      apiClient.request(uri, { ...options, method: 'DELETE' }),\n\n    /**\n     * Uploads files using FormData.\n     * \n     * @param {string} uri - The URI to upload to\n     * @param {Object} data - Key-value pairs to include in FormData\n     * @param {Object} [options] - Additional request options\n     * @returns {Promise<any>} The response data\n     */\n    upload: (uri, data, options) => {\n      const formData = new FormData();\n      Object.entries(data).forEach(([key, value]) => {\n        formData.append(key, value);\n      });\n      return apiClient.request(uri, { body: formData, ...options, method: 'POST' });\n    },\n\n    /**\n     * Executes multiple requests in parallel using Promise.all.\n     * \n     * @param {Array<Object>} requests - Array of request configurations\n     * @param {string} requests[].method - HTTP method (get, post, put, delete)\n     * @param {string} requests[].uri - Request URI\n     * @param {Object} [requests[].params] - Query parameters (for GET)\n     * @param {any} [requests[].body] - Request body (for POST/PUT)\n     * @returns {Promise<Array>} Array of response data in the same order as requests\n     */\n    all: (requests) => {\n      const requestPromises = requests.map((requestConfig) => {\n        const { method = 'get', uri, ...requestOptions } = requestConfig;\n        const lowerMethod = method.toLowerCase();\n        \n        if (apiClient[lowerMethod]) {\n          const payload = requestOptions.params || requestOptions.body;\n          return apiClient[lowerMethod](uri, payload, requestOptions);\n        }\n        \n        return Promise.reject(\n          new Error(`Invalid HTTP method '${method}' in parallel request configuration`)\n        );\n      });\n      \n      return Promise.all(requestPromises);\n    },\n  };\n\n  return apiClient;\n};\n","import { createApiClient } from '../libraries/ApiClient';\n\n/**\n * Creates and manages a singleton registry of ApiClient instances.\n * Provides centralized API client management with default client support and proxy methods.\n * \n * @returns {Object} The manager instance with register, use, and proxy methods\n */\nconst createApiManager = () => {\n  const registeredClients = new Map();\n  let defaultClientName = null;\n\n  const apiManager = {\n    /**\n     * Registers a new, named ApiClient instance.\n     * \n     * @param {string} name - The unique name for this client\n     * @param {Object} config - The configuration object for createApiClient\n     * @param {boolean} [isDefault=false] - If true, sets this client as the default\n     * @returns {Object} The newly created ApiClient instance\n     * @throws {Error} If name is already registered or a default already exists\n     */\n    register: (name, config, isDefault = false) => {\n      if (!name || typeof name !== 'string') {\n        throw new Error('API client name must be a non-empty string');\n      }\n      \n      if (registeredClients.has(name)) {\n        throw new Error(`An API client named '${name}' is already registered`);\n      }\n      \n      if (isDefault && defaultClientName) {\n        throw new Error(\n          `A default API client ('${defaultClientName}') is already registered. ` +\n          `Cannot set '${name}' as a second default`\n        );\n      }\n\n      const apiClient = createApiClient(config);\n      registeredClients.set(name, apiClient);\n\n      if (isDefault) {\n        defaultClientName = name;\n      }\n\n      return apiClient;\n    },\n\n    /**\n     * Retrieves a registered ApiClient instance by name.\n     * \n     * @param {string} [name] - The name of the client to retrieve. If omitted, returns the default client\n     * @returns {Object} The ApiClient instance\n     * @throws {Error} If no name provided and no default set, or if named client doesn't exist\n     */\n    use: (name) => {\n      const clientName = name || defaultClientName;\n\n      if (!clientName) {\n        throw new Error(\n          'manager.use() was called without a name, but no default client has been registered'\n        );\n      }\n\n      const apiClient = registeredClients.get(clientName);\n\n      if (!apiClient) {\n        throw new Error(`No API client named '${clientName}' has been registered`);\n      }\n\n      return apiClient;\n    },\n\n    /**\n     * Checks if a client with the given name has been registered.\n     * \n     * @param {string} name - The name of the client to check\n     * @returns {boolean} True if the client is registered, false otherwise\n     */\n    isRegistered: (name) => {\n      return registeredClients.has(name);\n    },\n\n    /**\n     * Gets the name of the default client, if one is set.\n     * \n     * @returns {string|null} The default client name or null if none set\n     */\n    getDefaultClientName: () => defaultClientName,\n\n    /**\n     * Gets a list of all registered client names.\n     * \n     * @returns {string[]} Array of registered client names\n     */\n    getRegisteredClientNames: () => Array.from(registeredClients.keys()),\n  };\n\n  // Dynamically create proxy methods by inspecting a template client\n  const templateClient = createApiClient({ baseUrl: '' });\n  const clientMethods = ['request', 'get', 'post', 'put', 'del', 'upload', 'all', 'abort', 'setHeader', 'unsetHeader', 'clearHeaders'];\n\n  clientMethods.forEach(methodName => {\n    if (typeof templateClient[methodName] === 'function') {\n      /**\n       * Proxy method that forwards calls to the default client.\n       * Throws an error if no default client is registered.\n       */\n      apiManager[methodName] = (...args) => {\n        const defaultClient = apiManager.use(); // Throws if no default is set\n        return defaultClient[methodName](...args);\n      };\n    }\n  });\n\n  return apiManager;\n};\n\n/**\n * The singleton instance of the ApiManager.\n * This is the main export that should be used throughout the application.\n */\nexport const manager = createApiManager();\n\n/**\n * Export the factory function for testing purposes.\n */\nexport { createApiManager };\n","import {useState, useRef, useEffect, useCallback, useMemo} from 'react';\n\n/**\n * A unified and flexible base hook for handling API requests.\n * @param {object} options - The configuration options for the hook.\n * @returns {object} The API state and methods.\n */\nexport const useApiBase = (options = {}) => {\n  if (!options.apiManager) {\n    throw new Error('useApiBase requires an `apiManager` instance to be provided in the options.');\n  }\n\n  // Memoize the settings object to prevent re-renders from causing dependency changes.\n  const settings = useMemo(\n    () => ({\n      uri: '',\n      initialParams: {},\n      params: undefined, // Allow for controlled params\n      globalStore: null,\n      dataPath: '',\n      runOnMount: false,\n      alwaysRunOnMount: false,\n      runOnFocus: false,\n      runOnParamsChange: false,\n      refreshDependencies: [],\n      validateParams: () => true,\n      abortOnUnmount: true,\n      abortOnBlur: true,\n      filterParams: params => params,\n      filterResponse: data => data,\n      onSubmit: () => {},\n      onSuccess: () => {},\n      onError: () => {},\n      onCompleted: () => {},\n      onRefresh: () => {},\n      pagination: null,\n      ...options,\n    }),\n    [options],\n  );\n\n  const [params, setParams] = useState(settings.initialParams || settings.params);\n  const [error, setError] = useState(null);\n  const [loadingStates, setLoadingStates] = useState({\n    isInitialLoading: settings.runOnMount,\n    isRefreshing: false,\n    isLoadingMore: false,\n  });\n\n  const apiClient = useRef(settings.apiManager);\n  const lastFetchTimestamp = useRef(0);\n  const hasFetchedOnce = useRef(false);\n  const isMounted = useRef(true);\n  const debounceTimer = useRef(null);\n  const previousParams = useRef(params);\n\n  const localResponseState = useState(settings.pagination ? {results: []} : null);\n  const hasGlobalStore = !!(settings.globalStore && settings.dataPath);\n\n  const response = useMemo(\n    () => (hasGlobalStore ? settings.globalStore.use(settings.dataPath) : localResponseState[0]),\n    [hasGlobalStore, settings.globalStore, settings.dataPath, localResponseState],\n  );\n\n  const setResponse = useCallback(\n    value => (hasGlobalStore ? settings.globalStore.update(settings.dataPath, value) : localResponseState[1](value)),\n    [hasGlobalStore, settings.globalStore, settings.dataPath, localResponseState],\n  );\n\n  // Effect to sync internal params state if `params` prop is provided (controlled hook).\n  const paramsPropString = useMemo(() => JSON.stringify(settings.params), [settings.params]);\n  useEffect(() => {\n    if (settings.params) {\n      setParams(settings.params);\n    }\n  }, [paramsPropString, settings.params]);\n\n  useEffect(() => {\n    isMounted.current = true;\n    return () => {\n      isMounted.current = false;\n    };\n  }, []);\n\n  useEffect(() => {\n    if (hasGlobalStore) {\n      const existingData = settings.globalStore.get(settings.dataPath);\n      if (existingData) {\n        setLoadingStates(prev => ({...prev, isInitialLoading: false}));\n      }\n    }\n  }, [hasGlobalStore, settings.globalStore, settings.dataPath]);\n\n  const send = useCallback(\n    async (mode = 'initial', oneTimeParams = {}) => {\n      if (loadingStates.isInitialLoading || loadingStates.isRefreshing) {\n        if (mode !== 'pagination' || !settings.pagination) return;\n      }\n\n      setLoadingStates(prev => ({\n        ...prev,\n        isInitialLoading: mode === 'initial' && !hasFetchedOnce.current,\n        isRefreshing: mode === 'refresh',\n        isLoadingMore: mode === 'pagination',\n      }));\n      setError(null);\n\n      const currentParams = {...params, ...oneTimeParams};\n      if (mode === 'pagination' && settings.pagination) {\n        const currentResponse = hasGlobalStore ? settings.globalStore.get(settings.dataPath) : response;\n        const page = currentResponse?.metadata?.page || 0;\n        currentParams.page = page + 1;\n      }\n      const finalParams = settings.filterParams(currentParams);\n\n      if (!settings.validateParams(finalParams)) {\n        setLoadingStates({isInitialLoading: false, isRefreshing: false, isLoadingMore: false});\n        return;\n      }\n\n      await settings.onSubmit();\n      if (mode === 'refresh') await settings.onRefresh();\n\n      try {\n        // NOTE: Defaulting to `post` for data submission. Change if your API uses GET for queries with bodies.\n        const apiResponse = await apiClient.current.request(`post:${settings.uri}`, {body: finalParams});\n\n        if (!isMounted.current || apiResponse === null) return; // Aborted or unmounted\n\n        const filteredData = settings.filterResponse(apiResponse);\n        lastFetchTimestamp.current = Date.now();\n        hasFetchedOnce.current = true;\n\n        if (settings.pagination) {\n          const newResults = settings.pagination.getResults(apiResponse);\n          const newMetadata = settings.pagination.getMetadata(apiResponse);\n          const currentResponse = hasGlobalStore ? settings.globalStore.get(settings.dataPath) : response;\n          const mergedResults = settings.pagination.merge(currentResponse?.results, newResults, currentParams.page);\n          setResponse({results: mergedResults, metadata: newMetadata});\n        } else {\n          setResponse(filteredData);\n        }\n\n        await settings.onSuccess(filteredData, finalParams);\n      } catch (err) {\n        if (isMounted.current) setError(err);\n        await settings.onError(err);\n      } finally {\n        if (isMounted.current) {\n          setLoadingStates({isInitialLoading: false, isRefreshing: false, isLoadingMore: false});\n          await settings.onCompleted();\n        }\n      }\n    },\n    [params, settings, hasGlobalStore, response, loadingStates, setResponse],\n  );\n\n  useEffect(() => {\n    if (settings.abortOnUnmount) {\n      const client = apiClient.current;\n      return () => client.abort();\n    }\n  }, [settings.abortOnUnmount]);\n\n  useEffect(() => {\n    const shouldFetch = settings.runOnMount && (!hasFetchedOnce.current || settings.alwaysRunOnMount);\n    if (shouldFetch) {\n      const existingData = hasGlobalStore ? settings.globalStore.get(settings.dataPath) : null;\n      if (!existingData || settings.alwaysRunOnMount) {\n        send('initial');\n      }\n    }\n  }, [settings.runOnMount, settings.alwaysRunOnMount, send, hasGlobalStore, settings.globalStore, settings.dataPath]);\n\n  const refreshDependencyKey = useMemo(() => JSON.stringify(settings.refreshDependencies), [settings.refreshDependencies]);\n  useEffect(() => {\n    if (hasFetchedOnce.current && settings.refreshDependencies.length > 0) {\n      send('refresh');\n    }\n  }, [send, refreshDependencyKey]);\n\n  useEffect(() => {\n    if (!settings.runOnParamsChange || !hasFetchedOnce.current) return;\n    if (JSON.stringify(params) === JSON.stringify(previousParams.current)) return;\n    previousParams.current = params;\n\n    const debounceMs = typeof settings.runOnParamsChange === 'number' ? settings.runOnParamsChange : 300;\n    if (debounceTimer.current) clearTimeout(debounceTimer.current);\n    debounceTimer.current = setTimeout(() => send('refresh'), debounceMs);\n  }, [params, settings.runOnParamsChange, send]);\n\n  const refresh = useCallback(() => send('refresh'), [send]);\n\n  const loadMore = useCallback(() => {\n    const currentResponse = hasGlobalStore ? settings.globalStore.get(settings.dataPath) : response;\n    if (settings.pagination && currentResponse?.metadata?.hasMore) {\n      send('pagination');\n    }\n  }, [send, settings.pagination, response, hasGlobalStore, settings.globalStore, settings.dataPath]);\n\n  const updateParams = useCallback(updates => setParams(prev => ({...prev, ...updates})), []);\n  const handleOnChange = useCallback(key => value => setParams(prev => ({...prev, [key]: value})), []);\n\n  const focus = useCallback(() => {\n    if (!settings.runOnFocus) return;\n    if (settings.runOnFocus === 'once' && hasFetchedOnce.current) return;\n    if (typeof settings.runOnFocus === 'number') {\n      if (Date.now() - lastFetchTimestamp.current < settings.runOnFocus * 1000) return;\n    }\n    refresh();\n  }, [settings.runOnFocus, refresh]);\n\n  const blur = useCallback(() => {\n    if (settings.abortOnBlur) {\n      apiClient.current.abort();\n    }\n  }, [settings.abortOnBlur]);\n\n  return {\n    response,\n    error,\n    params,\n    hasMore: (hasGlobalStore ? settings.globalStore.get(settings.dataPath)?.metadata?.hasMore : response?.metadata?.hasMore) ?? false,\n    isLoading: loadingStates.isInitialLoading || loadingStates.isRefreshing || loadingStates.isLoadingMore,\n    isInitialLoading: loadingStates.isInitialLoading,\n    isRefreshing: loadingStates.isRefreshing,\n    isLoadingMore: loadingStates.isLoadingMore,\n    setResponse,\n    setParams,\n    updateParams,\n    handleOnChange,\n    send,\n    refresh,\n    loadMore,\n    focus,\n    blur,\n  };\n};\n","import {useEffect, useContext} from 'react';\nimport {NavigationContext} from '@react-navigation/native';\n\n/**\n * A hook that safely subscribes to React Navigation's focus and blur events.\n * @param {{onFocus: Function, onBlur: Function}} callbacks - Callbacks for focus and blur.\n */\nexport const useScreenFocus = ({onFocus, onBlur}) => {\n  const navigation = useContext(NavigationContext);\n\n  useEffect(() => {\n    if (!navigation) return;\n\n    const focusUnsubscribe = navigation.addListener('focus', () => {\n      if (onFocus) onFocus();\n    });\n\n    const blurUnsubscribe = navigation.addListener('blur', () => {\n      if (onBlur) onBlur();\n    });\n\n    return () => {\n      focusUnsubscribe();\n      blurUnsubscribe();\n    };\n  }, [navigation, onFocus, onBlur]);\n};\n","import {useState, useEffect, useRef} from 'react';\n\n/**\n * A hook for making multiple API requests in parallel.\n * @param {object} apiClient - An instance of the ApiClient.\n * @param {Array<object>} requests - An array of request configurations.\n * @returns {{data: Array|null, loading: boolean, error: Error|null}}\n */\nexport const useParallelApi = (apiClient, requests = []) => {\n  const [data, setData] = useState(null);\n  const [loading, setLoading] = useState(true);\n  const [error, setError] = useState(null);\n  const isMounted = useRef(true);\n\n  useEffect(() => {\n    isMounted.current = true;\n    return () => {\n      isMounted.current = false;\n    };\n  }, []);\n\n  useEffect(() => {\n    // Stringify the requests to create a stable dependency for the effect hook.\n    const requestKey = JSON.stringify(requests);\n\n    const fetchData = async () => {\n      setLoading(true);\n      setError(null);\n      try {\n        const responses = await apiClient.all(requests);\n        if (isMounted.current) {\n          setData(responses);\n        }\n      } catch (err) {\n        if (isMounted.current) {\n          setError(err);\n        }\n      } finally {\n        if (isMounted.current) {\n          setLoading(false);\n        }\n      }\n    };\n\n    if (requests.length > 0) {\n      fetchData();\n    } else {\n      setLoading(false);\n    }\n\n    return () => {\n      apiClient.abort();\n    };\n  }, [apiClient, requestKey]);\n\n  return {data, loading, error};\n};\n","import {useApiBase} from './useApiBase';\nimport {useScreenFocus} from './useScreenFocus';\n\n/**\n * A project-specific wrapper for `useApiBase` that automatically integrates\n * with React Navigation's focus and blur events.\n * @param {object} options - Configuration options for useApiBase.\n * @returns {object} The API state and methods.\n */\nexport const useApiNavigation = (options = {}) => {\n  const api = useApiBase(options);\n\n  useScreenFocus({\n    onFocus: api.focus,\n    onBlur: api.blur,\n  });\n\n  return api;\n};\n"],"mappings":"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","names":["config","params","_a","useEffect","useState","useEffect","useRef","requestKey"]}